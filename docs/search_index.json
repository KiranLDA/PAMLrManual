[
["index.html", "PAMLr Manual 1 Introduction 1.1 Index 1.2 Package citation 1.3 License", " PAMLr Manual Kiran Dhanjal-Adams 2019-04-25 1 Introduction This is a user manual accompanying the R package PAMLr, which provides a set of functions for analysing behaviour from multisensor geolocator data - primarily for small migratory birds (however the methods are generalisable). The package is setup for SOI-GDL3pam loggers (developped by the Swiss Ornithological Institute) which measure atmospheric pressure (P), activity (A), magnetisim (M), temperautre and light. However, other multisensor geolocator data may be used, if it is formatted in the same format as SOI-GDL3pam data (see Importing data). Figure 1.1: SOI-GDL3pam logger, (c) Marcel Burkhardt, Swiss Ornithological Institute 1.1 Index Installing PAMLr Importing data Visualising data Common data patterns Preparing data for analysis Analysis methods Classification accuracy Classifying migratory flapping flight in Hoopoes Classifying migratory flight in European bee-eaters Classifying migratory flight in Alpine Swifts A few last things to think about 1.2 Package citation Dhanjal-Adams K.L., Willener A.S. T. &amp; Liechti F. (201x) PAMLr: a toolbox for analysing animal behaviour using Pressure, Acceleration, Temperature, Magnetic and Light data in R, Journal X 1.3 License This project is licensed under the GNU General Public License version 3 - see the LICENSE file for details "],
["install.html", "2 Installing PAMLr 2.1 Prerequisites 2.2 Installing", " 2 Installing PAMLr 2.1 Prerequisites To install this package from github, devtools must already be installed. install.packages(&quot;devtools&quot;) 2.2 Installing PAMLr can then be installed from github using the following code: devtools::install_github(&quot;KiranLDA/PAMLr&quot;) Note that if there are any problems with installing PAMLr, it is worth checking that the packages that PAMLr relies on are correctly installed (using install.packages()). These include: changepoint cluster data.table depmixS4 dplyr dygraphs EMbC GeoLight graphics grDevices htmltools raster rgl viridis xts zoo Any errors such as: Error in loadNamespace(i, c(lib.loc, .libPaths()), versionCheck = vI[[i]]) : there is no package called ‘rlang’ Can be dealt with through: install.packages(&quot;rlang&quot;) "],
["import.html", "3 Importing data 3.1 Load PAMLr 3.2 Use existing data 3.3 Import your own data 3.4 Data details 3.5 Temporal resolution of data 3.6 Cropping the data 3.7 Table references", " 3 Importing data 3.1 Load PAMLr library(PAMLr) 3.2 Use existing data PAMLr has three integrated datasets for exploring the code. These include: 3.2.1 Hoopoe (Upupa epops) data(&quot;hoopoe&quot;) Figure 3.1: Photograph by Shantanu Kuveskar, (c) creative commons 3.2.2 European Bee-eater (Merops apiaster) data(&quot;bee_eater&quot;) Figure 3.2: Photograph by El Golli Mohamed, (c) creative commons 3.2.3 Alpine Swift (Apus melba) data(&quot;swift&quot;) Figure 3.3: Photograph by Rudraksha Chodankar, (c) creative commons 3.3 Import your own data Importing data is easy with PAMLr. All data files should be found within the same directory which can be accessed through the pathname argument. Currently there are a list of supported file types, which include: “.pressure” “.glf” “.gle” “.acceleration” “.temperature” “.magnetic” It’s therefore possible to decide which of these to import. By default, all are imported. PAM_data = importPAM(pathname = &quot;C:/Put/your/path/here&quot;, measurements = c(&quot;.pressure&quot;, &quot;.glf&quot;, &quot;.acceleration&quot;, &quot;.temperature&quot;, &quot;.magnetic&quot;)` 3.4 Data details Once the PAM data are imported, they are stored as a nested list - with each element in the list containing a dataframe of measurements per date. For more details on the format of the data, use: PAM_data = hoopoe str(PAM_data) ## List of 6 ## $ id : chr &quot;16AJ&quot; ## $ pressure :&#39;data.frame&#39;: 37412 obs. of 2 variables: ## ..$ date: POSIXct[1:37412], format: &quot;2016-07-15 00:00:00&quot; ... ## ..$ obs : int [1:37412] 969 969 969 969 969 969 969 969 969 969 ... ## $ light :&#39;data.frame&#39;: 112401 obs. of 2 variables: ## ..$ date: POSIXct[1:112401], format: &quot;2016-07-15 00:00:00&quot; ... ## ..$ obs : int [1:112401] 0 0 0 0 0 0 0 0 0 0 ... ## $ acceleration:&#39;data.frame&#39;: 111900 obs. of 3 variables: ## ..$ date: POSIXct[1:111900], format: &quot;2016-07-15 00:00:00&quot; ... ## ..$ pit : int [1:111900] 10 10 10 10 10 10 11 11 11 11 ... ## ..$ act : int [1:111900] 0 0 0 0 0 0 2 0 0 0 ... ## $ temperature :&#39;data.frame&#39;: 36818 obs. of 2 variables: ## ..$ date: POSIXct[1:36818], format: &quot;2016-07-15 00:00:00&quot; ... ## ..$ obs : int [1:36818] 33 33 33 33 33 33 33 33 33 33 ... ## $ magnetic :&#39;data.frame&#39;: 1559 obs. of 7 variables: ## ..$ date: POSIXct[1:1559], format: &quot;2016-07-15 00:00:00&quot; ... ## ..$ gX : int [1:1559] 849 -487 211 505 725 -2048 454 -126 919 -886 ... ## ..$ gY : int [1:1559] -2035 -2182 -2601 -2581 -2507 -1847 -2582 -2650 -2437 -2574 ... ## ..$ gZ : int [1:1559] -1642 -1962 351 -20 118 -1626 41 -76 -152 -1327 ... ## ..$ mX : int [1:1559] -1600 -947 -2779 7 -1852 5844 1061 -118 -2196 2493 ... ## ..$ mY : int [1:1559] 15645 15610 15259 15549 15561 14545 16631 14548 15195 10924 ... ## ..$ mZ : int [1:1559] 5559 4627 6374 6147 5887 10881 5177 9000 6810 13793 ... Pressure data are recorded in hectopascals, generally every 15/30 minutes Light data are recorded in an arbitrary unit, generally every 2/5 minutes Acceleration data are summarised into two variables: act which is short for “activity”“, and is the sum of the difference in acceleration on the z-axis (i.e.”jiggle“). It is recorded every 5 minutes (summarised from 32 measurements - 10Hz) pit which is short for “pitch”, and is the relative position of the bird’s body relative to the z axis. It is an average over 32 measurements and is summarised every 5 minutes. Temperature data are recorded in degrees Celsius, generally every 15/30 minutes Magnetic data are in fact the combined recordings from a tri-axial accelerometer and magnetometer. gX, gY and gZ are snapshot tri-axial acceleration data, recorded every 4 hours. mX, mY and mZ are snapshot tri-axial magentic field data, recorded every 4 hours. 3.5 Temporal resolution of data Note that different sensors and loggers often collect data at different time intervals Table 3.1: Temporal resolution of difference multisensor loggers Sensor Logger Developper Resolution Life Reference Pressure PAM-logger SOI 15/30 min 1 year Dhanjal-Adams et al. (2018) activity logger CAMR 1h 1 year Sjöberg et al.(2018) OS barologgers CLA 1 min 13 days Shipley et al. (2017) Temperature PAM-logger SOI 15/30 min 1 year Liechti et al. (2018) activity logger CAMR 1 h 1 year Sjöberg et al.(2018) OS barologgers CLA 1 min 13 days Dreelin et al. (2018) Acceleration activity PAM-logger SOI 5 min 1 year Meier et al. (2018) activity logger CAMR 1h 1 year Bäckman et al. (2017) pitch PAM-logger SOI 5 min 1 year Liechti et al. (2018) tri-axial PAM-logger SOI 4 h 1 year Liechti et al. (2018) Magnetic tri-axial PAM-logger SOI 4 h 1 year Liechti et al. (2018) SOI = Swiss Ornithological Institute CAMR = Centre for Animal Movement Research CLA = Cornell Laboratory of Ornithology 3.6 Cropping the data Note that very often, a logger continues to record data before and after it is removed from a bird. For example, it might be transported in a rucksack or left in a laboratory until data are downloaded. It’s therefore important to remove these incorrect datapoints. This can be done using cutPAM. # make sure the cropping period is in the correct date format start = as.POSIXct(&quot;2016-07-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) end = as.POSIXct(&quot;2017-06-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) # Crop the data PAM_data= cutPAM(hoopoe,start,end) 3.7 Table references Bäckman, J., Andersson, A., Alerstam, T., Pedersen, L., Sjöberg, S., Thorup, K., &amp; Tøttrup, A. P. (2017). Activity and migratory flights of individual free-flying songbirds throughout the annual cycle: method and first case study. Journal of Avian Biology, 48(2), 309–319. doi:10.1111/jav.01068 Dhanjal-Adams, K. L., Bauer, S., Emmenegger, T., Hahn, S., Lisovski, S., &amp; Liechti, F. (2018). Spatiotemporal Group Dynamics in a Long-Distance Migratory Bird. Current Biology, 28(17), 2824–2830.e3. doi:10.1016/j.cub.2018.06.054 Dreelin, R. A., Shipley, J. R., &amp; Winkler, D. W. (2018). Flight Behavior of Individual Aerial Insectivores Revealed by Novel Altitudinal Dataloggers. Frontiers in Ecology and Evolution, 6, 182. doi:10.3389/fevo.2018.00182 Hedenström, A., Norevik, G., Warfvinge, K., Andersson, A., Bäckman, J., &amp; Åkesson, S. (2016). Annual 10-Month Aerial Life Phase in the Common Swift Apus apus. Current Biology, 26(22), 3066–3070. doi:10.1016/J.CUB.2016.09.014 Liechti, F., Bauer, S., Dhanjal-Adams, K. L., Emmenegger, T., Zehtindjiev, P., &amp; Hahn, S. (2018). Miniaturized multi-sensor loggers provide new insight into year-round flight behaviour of small trans-Sahara avian migrants. Movement Ecology, 6(1), 19. doi:10.1186/s40462-018-0137-1 Meier, C. M., Karaardıç, H., Aymí, R., Peev, S. G., Bächler, E., Weber, R., … Liechti, F. (2018). What makes Alpine swift ascend at twilight? Novel geolocators reveal year-round flight behaviour. Behavioral Ecology and Sociobiology, 72(3), 45. doi:10.1007/s00265-017-2438-6 Shipley, JR, Kapoor, J, Dreelin, RA, Winkler, DW. (2018) An open‐source sensor‐logger for recording vertical movement in free‐living organisms. Methods in Ecol Evol.; 9: 465– 471. doi:10.1111/2041-210X.12893 Sjöberg, S., Pedersen, L., Malmiga, G., Alerstam, T., Hansson, B., Hasselquist, D., … Bäckman, J. (2018). Barometer logging reveals new dimensions of individual songbird migration. Journal of Avian Biology, 49(9), e01821. doi:10.1111/jav.01821 "],
["dataviz.html", "4 Data Visualisation 4.1 Formatting data 4.2 Quick multiplots 4.3 Interactive timeseries 4.4 Sensor images 4.5 Histograms and three-dimensional scatterplots 4.6 Spherical projections", " 4 Data Visualisation 4.1 Formatting data Never forget to get rid of periods where ther logger is not on the bird # make sure the cropping period is in the correct date format start = as.POSIXct(&quot;2016-07-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) end = as.POSIXct(&quot;2017-07-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) # Crop the data PAM_data= cutPAM(hoopoe,start,end) 4.2 Quick multiplots For a quick look at the data, it’s possible to use quickPLOT. The user can specify which arguments to use, using measurements. There’s a choice between different combinations of &quot;pressure&quot;, &quot;light&quot;, &quot;acceleration&quot;, &quot;temperature&quot; and &quot;magnetic&quot;. You can add any parameters from ?plot, here I illustrate it with col=&quot;cornflowerblue&quot; and by showing how to restrict the x-axis limits xlim with the date format, to zoom into the post breeding mihration period of a hoopoe par(mar=c(3,4,0.5,0.5)) quickPLOT(hoopoe, col=&quot;cornflowerblue&quot;, measurements = c(&quot;pressure&quot;, &quot;light&quot;, &quot;acceleration&quot;), xlim=c(as.POSIXct(&quot;2016-08-20&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;), as.POSIXct(&quot;2016-09-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;))) 4.3 Interactive timeseries To have a better overview of the data, it is possible to create interactive dygraphPAM() plots which allow the user to compare different measurements recorded by the logger. These might for instance include light, temperature, pressure, activity, pitch and magnetism. If you are working from Rstudio, this bit of code should be run: # In Rstudio, it will display in the viewer by default and use a lot of ram, and is better in html backup_options &lt;- options() options(viewer=NULL) # ensure it is viewed in internet browser dygraphPAM(dta = PAM_data) # plot options(backup_options) # restore previous viewer settings If you are working from base R use this instead: To save space here we only plot only one variable - pressure . dygraphPAM(dta = PAM_data, toPLOT = c(&quot;pressure&quot;)) The reason there is additional code for Rstudio, is that by default it will open this graphic in the viewer pane and use up a lot of ram. This additional code allows the user to open this window in a browser instead of r studio, and the file can later be saved as an html file. With this interactive plot, the user can then zoom in and out of different plots to help get a feel for the data. For instance, this is a great way of seeing changes in the data which might be due to a logger being in a rucksack and no longer on the birds, or to look at how acticity or pressure might look during migration periods. It is possible to select areas to zoom into by right clicking and highighting certain regions, and to double click to zoom out. All plots are synched to the same time period and have a timeline at the bottom to increase or decrease the time over which the data is observed. 4.4 Sensor images Actograms are often used to plot activity over time at different hours of the day. However, the same approach can be used to plot any sensor data, not just activity. For simplicity, we name these “sensor images”. Plotting all sensors side by side is an important step for visualising data and developing an understanding of data patterns, and to start thinking about the behaviours that may be driving the observed patterns. PAMLr offers a function sensorIMG()for plotting sensor images, which can be implemented as follows. # Create plots with 3 together (mfrow) par( mfrow= c(1,3), oma=c(0,2,0,6)) par(mar = c(4,2,4,2)) sensorIMG(PAM_data$acceleration$date, ploty=FALSE, PAM_data$acceleration$act, main = &quot;Activity&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) par(mar = c(4,2,4,2)) sensorIMG(PAM_data$pressure$date, plotx=TRUE, ploty=FALSE, labely=FALSE, PAM_data$pressure$obs, main=&quot;Pressure&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) par(mar = c(4,2,4,2)) sensorIMG(PAM_data$temperature$date, labely=FALSE, PAM_data$temperature$obs, main=&quot;Temperature&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) 4.5 Histograms and three-dimensional scatterplots Histograms can provide a first impression of whether some of the data may be aggregated and therefore clustered. Indeed, sensor images may not always well-suited for visualising tri-axial data, such as magnetic field or acceleration. By plotting data in three dimensions (hereafter “3D”) using the function pam3D it’s possible to find patterns or clusters of datapoints which would not otherwise be apparent in the data. Here we plot magnetic data. pam3D(PAM_data$magnetic$gX, PAM_data$magnetic$gY, PAM_data$magnetic$gZ, xlab= &quot;X&quot;, ylab= &quot;Y&quot;, zlab= &quot;Z&quot;, xlim=c(-3000,3000), ylim=c(-3000,3000), zlim=c(-3000,3000)) You must enable Javascript to view this page properly. 4.6 Spherical projections 4.6.1 g-sphere A g-sphere is a method of visualising tri-axial acceleration data. This involves centering the data and plotting it on a sphere.The function triACC allows the user to center this data (as well as calculating pitch, roll and yaw from the data) # plot an g-phere calibration = triACC(dta = PAM_data$magnetic) pamSPHERE(x = calibration$centered_accx, y = calibration$centered_accy, z = calibration$centered_accz, ptcol = &quot;royalblue&quot;, ptsize = 0.03, linecolor =&quot;orange&quot;, spherecolor=&quot;orange&quot;, arrows=TRUE) 4.6.2 m-sphere An m-sphere is a method of visualising tri-axial magnetometer data. This involves centering the data and correcting the data, before plotting it on a sphere.The function triMAG calibrates the data. This provides the animal’s bearing. # plot a m-phere calibration = triMAG(dta = PAM_data$magnetic) pamSPHERE(x = calibration$calib_magx, y = calibration$calib_magy, z = calibration$calib_magz, ptcol = &quot;orange&quot;, ptsize = 0.03, linecolor =&quot;royalblue&quot;, spherecolor=&quot;royalblue&quot;, arrows=TRUE, cex=2) "],
["patterns.html", "5 Common data patterns 5.1 Incubation", " 5 Common data patterns Depending on the question, different patterns can be sought in the data to identify behaviour. Here, we outline migratory flight patterns, nesting, and foraging in small birds. However, there are many other patterns of interest which can be extracted from multisensor geolocator data including nesting success, altitudinal movements, twilight ascents, flocking behaviour, energy expenditure during flights… It is therefore important to think about the ecology of the species to determine what the patterns of interest might be relevant for answering the question that is being asked. 5.0.1 Migration In small migratory birds, there are often three strong data signals corresponding to their yearly behaviour - breeding, migration and non-breeding residency (also termed “wintering” by some). However, sensor data patterns can vary substantially from species to species, depending on their flight strategy. 5.0.1.1 Flapping birds Firstly, flapping birds exert high amounts of energy to maintain their wings in constant movement. This migratory strategy is most common in passerines and therefore small birds. Because of this, birds with this flapping migratory strategy tend to avoid turbulence which is highest during the day, instead preferring to fly at night. Therefore, the pattern of interest for migratory flapping birds is a high and sustained night-time activity. In the figure below, this represents the yellow periods in september and march. par( mfrow= c(1,1), oma=c(0,2,0,6)) par(mar = c(4,2,4,2)) sensorIMG(hoopoe$acceleration$date, hoopoe$acceleration$act, main = &quot;Activity&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) 5.0.2 Flap-gliding birds Secondly, flap-gliding birds remain airborne for long periods of time (often months) without resting. This migratory strategy is most common in swifts and swallows. Such birds do not show any big changes in behaviour between night and day, or between migration and non-breeding residency. However, during migration they can fly at higher altitudes than at other times of the year, rest less often with longer periods of sustained activity, display a constant pitch, and experience lower temperatures (because of the altitude) – some or all of these patterns can be used to classify such behaviour. par( mfrow= c(1,1), oma=c(0,2,0,6)) par(mar = c(4,2,4,2)) sensorIMG(swift$acceleration$date, swift$acceleration$act, main = &quot;Activity&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) 5.0.3 Soar-gliding birds Finally, soar-gliding birds take advantage of thermal updrafts to remain airborne and avoid using too much energy beating their wings. This strategy is most commonly observed in raptors, cranes and storks, but also bee-eaters. Because thermal updrafts are only present during the day, such species only migrate during the day. Therefore, patterns of interest include rapid changes in daytime altitude, as well as decreases in resting time and continuous sunlight (particularly for a species which might otherwise spend time under tree canopy). par(mfrow= c(1,3), # number of panels oma=c(0,2,0,6), # outer margin around all panels mar = c(4,1,4,1)) # inner margin around individual fivure sensorIMG(bee_eater$acceleration$date, ploty=FALSE, bee_eater$acceleration$act, main = &quot;Activity&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(bee_eater$pressure$date, plotx=TRUE, ploty=FALSE, labely=FALSE, bee_eater$pressure$obs, main=&quot;Pressure&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(bee_eater$light$date, labely=FALSE, bee_eater$light$obs, main=&quot;Light&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) 5.1 Incubation Patterns are often easy to distinguish in cavity nesting birds. Most commonly, darkness can be used to determine when birds are entering or exiting the cavity. However, for species which are not cavity nesters, extended periods of inactivity, combined with remaining at the same altitude, can also be used to find when the bird is sitting on the nest. par( mfrow= c(1,2), oma=c(0,2,0,6)) par(mar = c(4,2,4,2)) #Subset the data to only the breeding season PAM_data = cutPAM(bee_eater, start = as.POSIXct(&quot;2016-05-15&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;), end = as.POSIXct(&quot;2016-07-15&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;)) sensorIMG(PAM_data$acceleration$date, ploty=FALSE, log(PAM_data$acceleration$act+0.001), main = &quot;Activity&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(PAM_data$light$date, labely=FALSE, PAM_data$light$obs, main=&quot;Light&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) "],
["dataprep.html", "6 Preparing data for analysis 6.1 Merge sensor data together 6.2 Rolling window 6.3 Extracting statistics for specific data patterns", " 6 Preparing data for analysis There are multiple ways of preparing data for analysis. reducePAM: The most simple is to merge the data together (at the same resolution). rollPAM: It’s also possible to derive summary statistics using a rolling window, which progresses across the timeseries to make calculations. pamPREP: Where there is a particular pattern that need to be extracted from the data such as sustained pressure change or activity, this function derives summary statistics for these periods 6.1 Merge sensor data together Because data from different sensors are collected at different temporal resolutions (e.g. 5 minutes, 30 mintues or4 hours), reducePAM formats data to the same time intervals as a specified variable (e.g. pressure) by summarising finer resolution data (median, sum or skip) and interpolating (or not) lower resolution data. # Crop the data start = as.POSIXct(&quot;2015-08-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) end = as.POSIXct(&quot;2016-06-21&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) PAM_data = cutPAM(bee_eater, start, end) 6.1.1 Interpolation Format it for every 30 mins and interpolate data with larger intervals, and provide median for data with smaller intervals. TOclassify = reducePAM(PAM_data , &quot;pressure&quot;, interp = TRUE, summary=&quot;median&quot;) Table 6.1: A table of the first 10 rows of a reducePAM dataset. date pressure light pit act temperature gX gY gZ mX mY mZ 2015-08-01 00:00:00 1004 0 24 0 33 796.00 -1993.000 -4741 -2016.000 11156 12528.0 2015-08-01 00:30:00 1004 0 24 0 33 854.75 -1630.875 -4661 -2759.125 10517 11372.5 2015-08-01 01:00:00 1004 0 24 0 33 913.50 -1268.750 -4581 -3502.250 9878 10217.0 2015-08-01 01:30:00 1004 0 24 0 33 972.25 -906.625 -4501 -4245.375 9239 9061.5 2015-08-01 02:00:00 1004 0 24 0 33 1031.00 -544.500 -4421 -4988.500 8600 7906.0 2015-08-01 02:30:00 1004 0 24 0 33 1089.75 -182.375 -4341 -5731.625 7961 6750.5 6.1.2 No interpolation Format it for every 5 minutes and don’t interpolate anything TOclassify = reducePAM(PAM_data , &quot;acceleration&quot;, interp = FALSE) 6.2 Rolling window Interpolation is not always advisable (especially linear), and another alternative for formatting data for analysis is to use a rolling window with rollPAM, which progresses across all the timeseries and creates summary statistics for the data contained within that window of a certain time. Derived variables include: median : Median sd : Standard deviation sum : Cumulative sum of values min : Minimum max : Maximum range : Range (i.e. maximum - minimum) cumu_diff : Cumulative difference (i.e. sum of absolute differences) 6.2.1 Interpolation Create a 2h window with summary statistics every 15 minutes. Because sensors such as the magnetometer record every 4 hours, we can avoid spaces in the dataset by interpolating between points (linearly) and then calculating summary statistics for these interpolated points. TOclassify = rollPAM(PAM_data, resolution_out = 15 , window = 120) Table 6.2: A table of the first 10 rows of a reducePAM dataset. date pressure light pit act temperature gX gY gZ mX mY mZ median_pressure median_light median_pit median_act median_temperature median_gX median_gY median_gZ median_mX median_mY median_mZ sd_pressure sd_light sd_pit sd_act sd_temperature sd_gX sd_gY sd_gZ sd_mX sd_mY sd_mZ sum_pressure sum_light sum_pit sum_act sum_temperature sum_gX sum_gY sum_gZ sum_mX sum_mY sum_mZ min_pressure min_light min_pit min_act min_temperature min_gX min_gY min_gZ min_mX min_mY min_mZ max_pressure max_light max_pit max_act max_temperature max_gX max_gY max_gZ max_mX max_mY max_mZ cumu_diff_pressure cumu_diff_light cumu_diff_pit cumu_diff_act cumu_diff_temperature cumu_diff_gX cumu_diff_gY cumu_diff_gZ cumu_diff_mX cumu_diff_mY cumu_diff_mZ range_pressure range_light range_pit range_act range_temperature range_gX range_gY range_gZ range_mX range_mY range_mZ 2015-08-01 00:45:00 1004 0 24 0 33 884.125 -1449.8125 -4621 -3130.688 10197.5 10794.75 1004 0 24 0 33 898.8125 -1359.2812 -4601 -3316.469 10037.75 10505.875 0.0000000 0 0.3535534 0 0 71.95376 443.5107 97.97959 910.1385 782.612 1415.193 8032.0 0 191 0 264 7190.5 -10874.25 -36808 -26531.75 80302 84047 1004.0 0 23 0 33 796.000 -1993.000 -4741 -4616.938 8919.5 8483.75 1004 0 24 0 33 1001.625 -725.5625 -4461 -2016.000 11156.0 12528.00 0.0 0 2 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 0.0 0 1 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 2015-08-01 01:00:00 1004 0 23 0 33 913.500 -1268.7500 -4581 -3502.250 9878.0 10217.00 1004 0 24 0 33 928.1875 -1178.2188 -4561 -3688.031 9718.25 9928.125 0.0000000 0 0.3535534 0 0 71.95376 443.5107 97.97959 910.1385 782.612 1415.193 8032.0 0 191 0 264 7425.5 -9425.75 -36488 -29504.25 77746 79425 1004.0 0 23 0 33 825.375 -1811.938 -4701 -4988.500 8600.0 7906.00 1004 0 24 0 33 1031.000 -544.5000 -4421 -2387.562 10836.5 11950.25 0.0 0 2 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 0.0 0 1 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 2015-08-01 01:15:00 1004 0 24 0 33 942.875 -1087.6875 -4541 -3873.812 9558.5 9639.25 1004 0 24 0 33 957.5625 -997.1562 -4521 -4059.594 9398.75 9350.375 0.0000000 0 0.3535534 0 0 71.95376 443.5107 97.97959 910.1385 782.612 1415.193 8032.0 0 191 0 264 7660.5 -7977.25 -36168 -32476.75 75190 74803 1004.0 0 23 0 33 854.750 -1630.875 -4661 -5360.062 8280.5 7328.25 1004 0 24 0 33 1060.375 -363.4375 -4381 -2759.125 10517.0 11372.50 0.0 0 2 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 0.0 0 1 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 2015-08-01 01:30:00 1004 0 24 0 33 972.250 -906.6250 -4501 -4245.375 9239.0 9061.50 1004 0 24 0 33 986.9375 -816.0938 -4481 -4431.156 9079.25 8772.625 0.0000000 0 0.3535534 0 0 71.95376 443.5107 97.97959 910.1385 782.612 1415.193 8032.0 0 191 0 264 7895.5 -6528.75 -35848 -35449.25 72634 70181 1004.0 0 23 0 33 884.125 -1449.812 -4621 -5731.625 7961.0 6750.50 1004 0 24 0 33 1089.750 -182.3750 -4341 -3130.688 10197.5 10794.75 0.0 0 2 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 0.0 0 1 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 2015-08-01 01:45:00 1004 0 24 0 33 1001.625 -725.5625 -4461 -4616.938 8919.5 8483.75 1004 0 24 0 33 1016.3125 -635.0312 -4441 -4802.719 8759.75 8194.875 0.1767767 0 0.3535534 0 0 71.95376 443.5107 97.97959 910.1385 782.612 1415.193 8031.5 0 191 0 264 8130.5 -5080.25 -35528 -38421.75 70078 65559 1003.5 0 23 0 33 913.500 -1268.750 -4581 -6103.188 7641.5 6172.75 1004 0 24 0 33 1119.125 -1.3125 -4301 -3502.250 9878.0 10217.00 0.5 0 1 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 0.5 0 1 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 2015-08-01 02:00:00 1004 0 24 0 33 1031.000 -544.5000 -4421 -4988.500 8600.0 7906.00 1004 0 24 0 33 1045.6875 -453.9688 -4401 -5174.281 8440.25 7617.125 0.3720119 0 0.0000000 0 0 71.95376 443.5107 97.97959 910.1385 782.612 1415.193 8030.5 0 192 0 264 8365.5 -3631.75 -35208 -41394.25 67522 60937 1003.0 0 24 0 33 942.875 -1087.688 -4541 -6474.750 7322.0 5595.00 1004 0 24 0 33 1148.500 179.7500 -4261 -3873.812 9558.5 9639.25 1.0 0 0 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 1.0 0 0 0 0 205.625 1267.438 280 2600.938 2236.5 4044.25 6.2.2 No interpolation However, there are many assumpations made with assumptions (i.e. is the data truly linear). One option is either to increase the window to be larger than the greatest data resolution (in this case more than 4 hours). Another is to simply leave the NAs in the data using interp = FALSE TOclassify = rollPAM(PAM_data, resolution_out = 15 , window = 120, interp = FALSE) 6.3 Extracting statistics for specific data patterns If working with bird data, PAMLr offers some predefined functions for classifying behaviour. Flight bouts can be characterised by: continuous high activity which can be extracted from the data using pamPREP( ... ,method = &quot;flap&quot;) endurance activity using pamPREP( ... ,method = &quot;endurance&quot;) a pressure change greater than the background pressure changes due to weather using pamPREP( ... ,method = &quot;pressure&quot;) a period of continuous light using pamPREP( ... ,method = &quot;light&quot;) Incubation bouts can be characterised by: periods of darkness using pamPREP( ... ,method = &quot;darkness&quot;) periods of resting using pamPREP( ... ,method = &quot;rest&quot;) twl = GeoLight::twilightCalc(PAM_data$light$date, PAM_data$light$obs, LightThreshold = 2, ask = FALSE) TOclassify = pamPREP(dta = PAM_data, method= &quot;flap&quot;, twl = twl) Table 6.3: A table of the first 10 rows of a reducePAM dataset. date start end duration total_daily_duration total_daily_event_number cum_pressure_change cum_altitude_change cum_altitude_up total_daily_P_change P_dep_arr pressure_range altitude_range mean_night_P sd_night_P mean_nextnight_P sd_nextnight_P night_P_diff median_activity sum_activity prop_resting prop_active mean_night_act sd_night_act sum_night_act mean_nextnight_act sd_nextnight_act sum_nextnight_act night_act_diff median_pitch sd_pitch median_light nightime median_gX median_gY median_gZ median_mX median_mY median_mZ median_temp sd_temp cum_temp_change 2015-08-01 2015-08-01 12:05:00 2015-08-01 12:30:00 0.4166667 0.9166667 4 0 0 0 0 0 0 0 1001.938 0.4425306 1004.938 0.4425306 3.00 16 100 0.1666667 0.8333333 0.0210526 0.1443214 2 0.0107527 0.1036952 1 0.0102999 20 7.842194 9984 0 NA NA NA NA NA NA 41 NA 0 2015-08-01 2015-08-01 15:10:00 2015-08-01 15:20:00 0.1666667 0.9166667 4 0 0 0 0 1 NA NA 1001.938 0.4425306 1004.938 0.4425306 3.00 27 56 0.0000000 1.0000000 0.0210526 0.1443214 2 0.0107527 0.1036952 1 0.0102999 36 10.392305 9984 0 NA NA NA NA NA NA NA NA 0 2015-08-01 2015-08-01 04:30:00 2015-08-01 04:40:00 0.1666667 0.9166667 4 0 0 0 0 0 0 0 1001.938 0.4425306 1004.938 0.4425306 3.00 30 76 0.3333333 0.6666667 0.0210526 0.1443214 2 0.0107527 0.1036952 1 0.0102999 20 9.451631 424 0 NA NA NA NA NA NA 34 NA 0 2015-08-01 2015-08-01 10:00:00 2015-08-01 10:10:00 0.1666667 0.9166667 4 0 0 0 0 0 0 0 1001.938 0.4425306 1004.938 0.4425306 3.00 43 113 0.3333333 0.6666667 0.0210526 0.1443214 2 0.0107527 0.1036952 1 0.0102999 13 4.509250 9984 0 NA NA NA NA NA NA 39 NA 0 2015-08-02 2015-08-02 11:00:00 2015-08-02 11:10:00 0.1666667 1.4166667 6 0 0 0 0 0 0 0 1004.938 0.4425306 1001.188 0.5439056 3.75 19 39 0.3333333 0.6666667 0.0107527 0.1036952 1 0.0319149 0.2296387 3 0.0211622 21 8.144528 9984 0 NA NA NA NA NA NA 40 NA 0 2015-08-02 2015-08-02 11:30:00 2015-08-02 11:50:00 0.3333333 1.4166667 6 0 0 0 0 0 0 0 1004.938 0.4425306 1001.188 0.5439056 3.75 23 109 0.2000000 0.8000000 0.0107527 0.1036952 1 0.0319149 0.2296387 3 0.0211622 30 6.913754 9984 0 NA NA NA NA NA NA 39 NA 0 These functions also calculate summary statistics for each event (e.g. flight bout). These include: date : Date (without time) start : Start time and date of the event, POSIXct format end : Time and date that the event finished, POSIXct format duration : How long it lasted (in hours) total_daily_duration : The total duration of all the events that occured that day (in hours) total_daily_event_number : The total number of events which occured that day cum_pressure_change : The cumulative change in atmospheric pressure during that event (in hectopascals) cum_altitude_change : The cumulative change in altitude during that event (in metres) cum_altitude_up : The cumulative number of metres that the bird went upwards during that event total_daily_P_change : The cumulative change in atmospheric pressure for all the events for that date (in hectopascals) P_dep_arr : The difference between atmospheric pressure at the start of the event, and at the end (in hectopascals) pressure_range : The total range of the atmospheric pressure during that event (maximum minus miniimum - in hectopascals) altitude_range : The total altitude range during that event (maximum minus miniimum - in metres) mean_night_P : The mean pressure during the night before the event took place (in hectopascals) sd_night_P : The standard deviation of pressure the night before the event took place (in hectopascals) mean_nextnight_P : The mean pressure the night after the event took place (in hectopascals) sd_nextnight_P : The standard deviation of pressure the night after the event took place (in hectopascals) night_P_diff : The difference between the mean pressures of the night before and the night after the event took place (in hectopascals) median_activity : The median activity during that event sum_activity : The sum of the activity during that event prop_resting : The propotion of time during that event where activity = 0 prop_active : The propotion of time during that event where activity &gt; 0 mean_night_act : The mean activity during the night before the event took place sd_night_act : The standard deviation of activity the night before the event took place sum_night_act : The summed activity during the night before the event took place mean_nextnight_act :The mean activity the night after the event took place sd_nextnight_act : The standard deviation of activity the night after the event took place sum_nextnight_act : The summed activity the night after the event took place night_act_diff : The difference between the mean activity of the night before and the night after the event took place median_pitch : The median pitch during that event sd_pitch : The standard deviation of pitch during that event median_light : The median light recordings during that event nightime : Whether or not it was night during the majority of the event (1= night, 0 = day) median_gX : Median raw acceledation on the x axis during the event median_gY : Median raw acceledation on the y axis during the event median_gZ : Median raw acceledation on the z axis during the event median_mX : Median raw magnetic field on the x axis during the event median_mY : Median raw magnetic field on the y axis during the event median_mZ : Median raw magnetic field on the z axis median_temp : Median temperature during the event (in celsius) sd_temp : Standard deviation of temperature during the event (in celsius) cum_temp_change : Cumulative absolute difference in temperature during the event (in celsius) "],
["method.html", "7 Classification methods 7.1 Changepoint 7.2 Cluster Analysis 7.3 Hidden Markov Models", " 7 Classification methods Once a behavioural pattern has been identified, there are a number of methods available for separating them from the data. Not all these methods should be used exclusively. Some can be used to complement each other, while others can be used interchangeably. Here we highlight changepoint analyses, principle component analyses, cluster analyses, hidden Markov models, 7.1 Changepoint Changepoint analyses can be used to find points in the data series which delineate a difference in variance, in mean or in both. There are a number of available methods for doing this and it is possible to constrain the number of changepoints allowed in the data. In PAMLr, the default setting in changePAM() are set for finding differences between migratory and non-migratory periods, but the user can customise these to fit their needs. 7.2 Cluster Analysis Clustering algorithms aim to partition a set of points into a k number of groups. Points are grouped (or clustered) together in a way that all the points in one cluster are more similar with each other, than with points in other clusters. PAMLr integrates three types of clustering algorithms, k-means, hierarchical and expectation-minimisation binary clustering. 7.2.1 k-means clustering k-means clustering minimises the within-cluster sum of squares of the points and is one of the commonly used clustering algorithms (Hartigan &amp; Wong, 1979). It can be implemented by using classifyPAM( … , method= “kmeans”). 7.2.2 Hierarchical clustering Hierarchical clustering analyses can either be agglomerative or divisive. The first relies on putting each datapoint in a single cluster and successively merging them until a stopping criterion is satisfied and can be implemented in PAMLr using classifyPAM( … , method= “agnes”). The divisive hierarchical clustering method starts by allocating all datapoints to the same cluster and splitting each cluster until a stopping criterion is met. This can be implemented using classifyPAM( … , method= “diana”). 7.2.3 Expectation-minimisation binary clustering Expectation-minimisation binary clustering (EMbC), clusters data based on geometry alone. More specifically binary delimiters are used to segregate the data along an axis, forcing centroids to lie within these binary regions. Analysis was undertaken using classifyPAM( … , method= “embc”). 7.3 Hidden Markov Models Hidden Markov Models (HMMs) are stochastic time-series models which assume that the observed time series (such as the measured acceleration, temperature or pressure) is driven by an unobservable state process (such as flying or resting behaviour). The unobserved states are allocated in a way that captures as much as possible of the marginal distribution of the observations, while also accounting for the correlation structure of the data. Thus, the probability of the system being in a state at time t depends on the state at time t-1, but is otherwise independent of any previous state. HMMs can be implemented in PAMLr using the function classifyPAM( … , method= “hmm”). "],
["accuracy.html", "8 Classification accuracy 8.1 Classify migratory flapping flight 8.2 Setup the reference dataset 8.3 Setup the prediction data 8.4 Compare the two classifications 8.5 Create a confusion Matrix 8.6 Overall accuracy", " 8 Classification accuracy To illustrate classification accuracy, here we compare two classifications of flapping migration. The first is using the inbuilt classifyFLAP function, the second is using pressure change. Both are then compared using compareCLASS and confusionMAT. 8.1 Classify migratory flapping flight Once a classification has been performed (here we use the example of a hoopoe, as it’s migratory flight can be prediction using classifyFLAP) data(&quot;hoopoe&quot;) # str(hoopoe) # make sure the cropping period is in the correct date format start = as.POSIXct(&quot;2016-07-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) end = as.POSIXct(&quot;2017-06-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) # Crop the data PAM_data= cutPAM(hoopoe,start,end) # perform one classification using classifyFLAP classification = classifyFLAP(dta = PAM_data$acceleration, period = 12, toPLOT = FALSE) This creates a timetable of migratory flight events which can be visualised using classification$timetable, as seen below: Table 8.1: Migration timetable (first 10 rows) start end Duration (h) 3 2016-08-06 20:20:00 2016-08-07 01:50:00 5.500000 4 2016-08-07 19:40:00 2016-08-08 09:15:00 13.583333 5 2016-08-08 19:30:00 2016-08-09 04:10:00 8.666667 6 2016-08-09 21:15:00 2016-08-10 01:30:00 4.250000 7 2016-08-10 22:30:00 2016-08-10 23:50:00 1.333333 8 2016-08-21 18:45:00 2016-08-22 04:15:00 9.500000 This classification is pretty accurate and we will use this as a reference dataset to compare with another classification: high pressure change. i.e. a high change in altitude. 8.2 Setup the reference dataset Because the second classification is done using pressure (30 minute data resolution) compared to this classification which was done using activity (5 minute resolution), the activity classification is set to the same resolution as pressure using the classification2PAM function. # Put the classification in the same resolution as pressure reference = classification2PAM(from = classification$timetable$start, to = classification$timetable$end, classification = rep_len(1,length(classification$timetable$end)), addTO = PAM_data$pressure, missing = 0) # Convert to categories reference = ifelse(reference == 1, &quot;Migration&quot;, &quot;Other&quot;) 8.3 Setup the prediction data Hoopoes seems to perform large altitudinal changes during migratory flight, so we preform a very rough classification by specifying that any altitude change greater than 2 hPa is equivalent to a migratory flight (this is for illustrative purposes only, and should not be used as a definite classification method). # Perform another classification using pressure difference prediction = c(&quot;Other&quot;,ifelse(abs(diff(PAM_data$pressure$obs))&gt;2, &quot;Migration&quot;, &quot;Other&quot;)) 8.4 Compare the two classifications We can then compare the two classifications point by point using the compareCLASS function. # both classes have been converted to the same time intervals as pressure, so use those dates date = PAM_data$pressure$date # Combine the classifications into a dataframe classifications = data.frame(reference= reference, # flapping classification prediction = prediction) # pressure difference classification class_comparison = compareCLASS(date=date, classifications=classifications) This puts both classifications side by side, and shows how many classifications provided each class, as well as the agreement between the two, as can be seen below. Table 6.2: Comparison of both classifications (first 10 rows) reference prediction Migration Other agreement Other Other 0 2 TRUE Other Other 0 2 TRUE Other Other 0 2 TRUE Other Other 0 2 TRUE Other Other 0 2 TRUE Other Other 0 2 TRUE 8.5 Create a confusion Matrix A confusion matrix uses predicted and reference points and estimate: Errors in Commission provide a measure of false negatives i.e. the number of points that were predicted to be part of a class that they were not (probability something was incorrectly prediction FN/(TP+FN)). Errors in Omission provide a measure of false positives that were predicted to be in a different class from their actual class (probability that something was missed FP/(FP +TP). Producer Accuracy or Precision provides a measure of how likely something was missed by the classification (probability that something was not missed TP/(TP + FP)). User Accuracy or Recall represents the probability that a class was correctly prediction TP/(TP + FN). Overall Accuracy represents the probability that all classes were correctly prediction (TP+TN)/(TP+TN+FP+FN). Kappa Coefficient measures the agreement between the classification and the truth ((TN+FP) (TN+FN) + (FN+TP) (FP+TP)) / (TP+FP+TN+FN)2 mat = confusionMAT(reference, prediction) Table 8.2: Confusion Matrix Ref Other Ref Migration Row_Total Commission_Error Users_accuracy Total_accuracy Kappa_Coeff Pred Other 2.990700e+04 104.0000000 30011 0.0034654 0.9965346 NA NA Pred Migration 8.000000e+01 726.0000000 806 0.0992556 0.9007444 NA NA Col_Total 2.998700e+04 830.0000000 30817 NA NA NA NA Omission_Error 2.667800e-03 0.1253012 NA NA NA NA NA Producers_accuracy 9.973322e-01 0.8746988 NA NA NA NA NA Total_accuracy NA NA NA NA NA 0.9940293 NA Kappa_Coeff NA NA NA NA NA NA 0.9483213 8.6 Overall accuracy The total accuracy is 99.4% which is not bad. Most of the error comes from the omission of some migration periods by the prediction i.e. there are periods where the bird is performing a migratory flight, but remains at the same altitude and are therefore missed by the classification. However, this is only for 1.25% of the points. "],
["flapping.html", "9 Example 1: Flapping 9.1 Classifying migratory flapping flight in Hoopoes :The dataset 9.2 Visualise data 9.3 What should we look for? 9.4 Performing the classification 9.5 Plot the classification as a sensor image", " 9 Example 1: Flapping Figure 9.1: Photograph by Frank Vassen, (c) creative commons 9.1 Classifying migratory flapping flight in Hoopoes :The dataset Hoopoes (Upupa epops) have been tracked on the their migrations from Switzerland (to sub-Saharan Africa) using SOI-GDL3pam loggers. Pressure is recorded every 15 minutes Light is recorded every 5 minutes Activity is recorded every 5 minutes Pitch is recorded every 5 minutes Temperature is recorded every 15 minutes Tri-axial acceleration is recorded every 4 hours Tri-axial magnetic field is recorded every 4 hours data(&quot;hoopoe&quot;) # str(hoopoe) # make sure the cropping period is in the correct date format start = as.POSIXct(&quot;2016-07-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) end = as.POSIXct(&quot;2017-06-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) # Crop the data PAM_data= cutPAM(hoopoe,start,end) 9.2 Visualise data Sensor images are a good place to start when analysing data, as they can give a rapid overview of the dataset. Darker colors represent lower values, and lighter colors (in this case yellow) represent higher values. Sensor images for activity (also known as an actogram), pitch, pressure and temperature are a good place to start. The following code plots this for us: par(mfrow= c(1,4), # number of panels oma=c(0,2,0,6), # outer margin around all panels mar = c(4,1,4,1)) # inner margin around individual fivure sensorIMG(PAM_data$acceleration$date, ploty=FALSE, PAM_data$acceleration$act, main = &quot;Activity&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(PAM_data$acceleration$date, plotx=TRUE, ploty=FALSE, labely=FALSE, PAM_data$acceleration$pit, main=&quot;Pitch&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(PAM_data$pressure$date, plotx=TRUE, ploty=FALSE, labely=FALSE, PAM_data$pressure$obs, main=&quot;Pressure&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(PAM_data$temperature$date, labely=FALSE, PAM_data$temperature$obs, main=&quot;Temperature&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) 9.3 What should we look for? Base on this plot, it is possible to see that nightime is the darker areas on the right and left sides of the plot, and daytime the “blob” in the middle. During the migratiory season (august/september and march), the nightime period is very different, with higher activity and pitch, and lower than usual temperature and pressure. These correspond to migratory flight periods. This can also be seen by cutting out a period in september are looking at the raw data. dygraphPAM(dta = cutPAM(PAM_data, as.POSIXct(&quot;2016-08-05&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;), as.POSIXct(&quot;2016-08-12&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;)), toPLOT = c(&quot;pressure&quot;, &quot;acceleration&quot;)) 9.4 Performing the classification Because flapping is widespread in birds, PAMLr integrates a pre-defined function classifyFLAP() to classify this behaviour. This function assumes that if the bird has displayed high activity for x number of consecutive minutes, then it is flapping. It is therefore important to think about what constitutes high activity and how long this period should be. At the moment, the function uses k-means clustering to identify the threshold between high and low activity. Using toPLOT = TRUE then allows the user to see where that threshold was drawn. The period of high activity is set by default to period = 3. This is because activity is recorded (on this logger) every 5 minutes and we assume that after an hour of high activity, the bird must be flapping. Thus “high activity duration” / “data resolution” = “period” and 60 minutes / 5 minutes = period of 12. # Classify behaviour behaviour = classifyFLAP(dta = PAM_data$acceleration, period = 12) str(behaviour) ## List of 7 ## $ timetable :&#39;data.frame&#39;: 32 obs. of 3 variables: ## ..$ start : POSIXct[1:32], format: &quot;2016-08-06 20:20:00&quot; ... ## ..$ end : POSIXct[1:32], format: &quot;2016-08-07 01:50:00&quot; ... ## ..$ Duration (h): num [1:32] 5.5 13.58 8.67 4.25 1.33 ... ## $ classification: num [1:92449] 0 0 0 0 0 0 1 0 0 0 ... ## $ no_movement : num 0 ## $ low_movement : num 1 ## $ high_movement : num 2 ## $ migration : num 3 ## $ threshold : num 13.5 This classification therefore provides different pieces of infomration. timetable shows when a migratory flapping flight started and stopped, and how long it lasted (in hours) classification is the output from the classification. In this case, each cluster/classs/state is represented by numbers between one 1 and 4. To find out what behaviour each of these numbers represent, we can refer to low_movement, high_movement, migration and no_movement threshold represents the threshold between high and low activity. Using these information, it’s therefore possible to plot the classification: # Plot behaviour col=col=c(&quot;black&quot;,&quot;royalblue4&quot;,&quot;brown&quot;,&quot;gold&quot;) index= 7300:8000 plot(PAM_data$acceleration$date[index],PAM_data$acceleration$act[index], type=&quot;l&quot;, xlab=&quot;Date&quot;, ylab=&quot;Activity&quot;) points(PAM_data$acceleration$date[index],PAM_data$acceleration$act[index], col=col[behaviour$classification+1][index], pch=16,) legend( PAM_data$acceleration$date[index[1]],60 , c(&quot;No activity&quot;, &quot;Low activity&quot;, &quot;High activity&quot;, &quot;Migration&quot; ) , col = col[c(behaviour$no_movement, behaviour$low_movement, behaviour$high_movement, behaviour$migration)+1], pch=20) 9.5 Plot the classification as a sensor image Another way of looking at a classification is to use a sensor image of the results and to plot it side by side with the raw data to see if the same patterns are being picked out. We can also add (for instance sunset and sunrise events) par(mfrow= c(1,3), # number of panels oma=c(0,2,0,6), # outer margin around all panels mar = c(4,1,4,1)) # inner margin around individual fivure sensorIMG(PAM_data$acceleration$date, ploty=FALSE, PAM_data$acceleration$act, main = &quot;Activity&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) legend(&quot;bottomright&quot;,cex=1.2, c(&quot;No Activity&quot;, &quot;Low Activity&quot;, &quot;High Activity&quot; ) , fill = c(&quot;black&quot;,&quot;royalblue3&quot;, &quot;orange&quot;), xpd = NA) sensorIMG(PAM_data$pressure$date, plotx=TRUE, ploty=FALSE, labely=FALSE, PAM_data$pressure$obs, main=&quot;Pressure&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) legend(&quot;bottomright&quot;,cex=1.2, c(&quot;Low Pressure&quot;, &quot;High Pressure&quot; ) , fill = c(&quot;royalblue3&quot;, &quot;orange&quot;), xpd = NA) sensorIMG(PAM_data$acceleration$date, labely=FALSE, behaviour$classification, main=&quot;Classification&quot;, col=col, cex=1.2, cex.main = 2) legend(&quot;bottomright&quot;,cex=1.2, # grconvertX(1, &quot;device&quot;), grconvertY(1, &quot;device&quot;), c(&quot;Resting&quot;, &quot;Active&quot;, &quot;Flapping&quot;, &quot;Migrating&quot; ) , fill = col, xpd = NA) "],
["soar.html", "10 Example 2: soar-gliding 10.1 Classifying migratory flight in European bee-eaters: the dataset 10.2 Visualise data 10.3 What should we look for? 10.4 What variables make the most sense for classifying? 10.5 Classify using HMM 10.6 Classify using pressure 10.7 Classify using a changepoint analysis 10.8 Compare the classifications", " 10 Example 2: soar-gliding Figure 10.1: Photograph by El Golli Mohamed, (c) creative commons 10.1 Classifying migratory flight in European bee-eaters: the dataset European bee-eaters (Merops apiaster) have been tracked on the their migrations from Germany (to the Congo Basin) using SOI-GDL3pam loggers. Pressure is recorded every 15 minutes Light is recorded every 5 minutes Activity is recorded every 5 minutes Pitch is recorded every 5 minutes Temperature is recorded every 15 minutes Tri-axial acceleration is recorded every 4 hours Tri-axial magnetic field is recorded every 4 hours data(&quot;bee_eater&quot;) # make sure the cropping period is in the correct date format start = as.POSIXct(&quot;2015-08-20&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) end = as.POSIXct(&quot;2016-06-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) # Crop the data PAM_data= cutPAM(bee_eater,start,end) 10.2 Visualise data Sensor images are a good place to start when analysing data, as they can give a rapid overview of the dataset. Darker colors represent lower values, and lighter colors (in this case yellow) represent higher values. Sensor images for activity (also known as an actogram), pitch, pressure and temperature are a good place to start. The following code plots this for us: par(mfrow= c(1,4), # number of panels oma=c(0,2,0,6), # outer margin around all panels mar = c(4,1,4,1)) # inner margin around individual fivure sensorIMG(PAM_data$acceleration$date, ploty=FALSE, PAM_data$acceleration$act, main = &quot;Activity&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(PAM_data$acceleration$date, plotx=TRUE, ploty=FALSE, labely=FALSE, PAM_data$acceleration$pit, main=&quot;Pitch&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(PAM_data$pressure$date, plotx=TRUE, ploty=FALSE, labely=FALSE, PAM_data$pressure$obs, main=&quot;Pressure&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(PAM_data$temperature$date, labely=FALSE, PAM_data$temperature$obs, main=&quot;Temperature&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) 10.3 What should we look for? Compared to the hoopoe, the activity patterns are less clear. However, there are some patterns become apparent. The bird is visibly never active at night - It only migrates during the day. During migration (August and April) the overall pressure changes from one night to the next (horizontal bars of different colors). Indeed pressure varies geographically and altitudinally - suggesting that those nights the bird is somewhere different. During this migration period, pressure drops substatially as does temperature - indicating higher altitude flights than ususal During the migration period, activity is low but sustained During the migration period, pitch is constant dygraphPAM(dta = PAM_data, toPLOT = &quot;pressure&quot;) Some, if not all of these can therefore be used to identify migratory flight in European bee-eaters. We could for instance use pamPREP(..., method=&quot;endurance&quot;) or pamPREP(..., method=&quot;pressure&quot;) based on these data patterns. However, because these species soar-glide and are therefore in sunlight while thermalling (as opposed to hidden under leaves), periods of constant sunshine could also be used to identify migratory soar-gliding usingpamPREP(..., method=&quot;light&quot;). 10.4 What variables make the most sense for classifying? We start with endurance flights. These can be extracted from the data using the following code. # get twilights (general geolocator method) twl = GeoLight::twilightCalc(PAM_data$light$date, PAM_data$light$obs, LightThreshold = 2, ask = FALSE) TOclassify = pamPREP(dta = PAM_data, method= &quot;endurance&quot;, light_thld = 2, twl = twl, interp = TRUE) # To look at the data use the following line. # Here it is commented out to avoid a messy document # head(TOclassify) We can then plot the data. Here, to save space, we plot the variables which on first glance seem to best distinguish migration from non-migration. These include: Long periods spend always activity: duration Active day where the bird changed pressure (i.e. altitude) a lot: total_daily_P_change Active periods where the pressure changed from one night to the next: night_P_diff Active periods where there were the bird’s body wasin a specific position: median_pitch par(mfrow= c(4,1), # number of panels oma=c(0,0,0,0), # outer margin around all panels mar = c(1,4,1,1)) # inner margin around individual fivure plot(TOclassify$date, TOclassify$duration, type = &quot;l&quot;, ylab = &quot;Event duration&quot;, xlab=&quot;&quot;) plot(TOclassify$date, TOclassify$total_daily_P_change, type = &quot;l&quot;, ylab = &quot;Cumul daily P chng&quot;, xlab=&quot;&quot;) plot(TOclassify$date, TOclassify$night_P_diff, type = &quot;l&quot;, ylab = &quot;Pressure diff btwn nights&quot;, xlab=&quot;&quot;) plot(TOclassify$date, TOclassify$median_pitch, type = &quot;l&quot;, ylab = &quot;Pitch&quot;, xlab=&quot;&quot;) 10.5 Classify using HMM There are two options for performing the classification of the data. One is to include multiple variables as is (see predictor 1 below). The other is to combine them into one metric (see predictor 2 below). The “hmm” method in classifyPAM relies on the package depmixS4, and by default classifyPAM treats each variable (i.e. a data column) with the formula variable ~ 1 with family = gaussian(). Family can easily be changed, however for a more complicated model, it is recommended to implement directly using the depmixS4 package. Beware - some methods do not allow any NAs in the dataset # Get rid of any extra NAs TOclassify = TOclassify[complete.cases(TOclassify),] # Select the columns to use as predictors in the model predictor = TOclassify[, c(&quot;duration&quot;, &quot;night_P_diff&quot;, &quot;median_pitch&quot;, &quot;total_daily_P_change&quot;)] # Perform the classification classification = classifyPAM(predictor, states=2, method = &quot;hmm&quot;) ## converged at iteration 15 with logLik: -8216.3 10.5.1 Translate the classification events into something usable The classification results in a series of numbers which can be accessed under classification$cluster. These indicate the states of the individual during a given event, in this case “migrating” and “not migrating”. However, we still need to figure out which number corresponds to which state, because these can be allocated randomly by the classification algorithm. First, we start by taking the classification, and adding the data from the flight events to the same resolution of the data that we want to plot, using classification2PAM(). For example, we use pressure, as this displays soar-gliding behaviour quite well. # Convert the events to data pressure_classification = classification2PAM(from = TOclassify$start, to = TOclassify$end, classification = classification$cluster, addTO = PAM_data$pressure) pressure_classification = data.frame(cluster=pressure_classification) To do so, we find the sate with the largest pressure difference, because it will indicate the state where the bird was changing altitude the most and therefore soar-gliding, which will be most obvious during migration. # Find the pressure difference for each state P_state1 = median(TOclassify$total_daily_P_change[classification$cluster == 1]) P_state2 = median(TOclassify$total_daily_P_change[classification$cluster == 2]) P_states = c(P_state1, P_state2) # Allocate the state with the highest pressure difference to migration Mig_state = which(P_states == max(P_states)) # Now add this information to the classification pressure_classification$states = pressure_classification$cluster pressure_classification$states[pressure_classification$cluster == Mig_state] = &quot;Migration&quot; pressure_classification$states[pressure_classification$cluster != Mig_state] = &quot;Active&quot; pressure_classification$states[is.na(pressure_classification$cluster)] = &quot;Unclassified&quot; # Associate each state with a color pressure_classification$colour = pressure_classification$cluster pressure_classification$colour[pressure_classification$cluster == Mig_state] = &quot;orange&quot; pressure_classification$colour[pressure_classification$cluster != Mig_state] = &quot;royalblue3&quot; pressure_classification$colour[is.na(pressure_classification$cluster)] = &quot;black&quot; 10.5.2 Plot the classification Here we only plot sowthward migration, to help visualise the classification results. par(mar=c(3,3,1,1)) # PLOT ALL THE DATA # plot the pressure data plot(PAM_data$pressure$date, PAM_data$pressure$obs, type=&quot;l&quot;, ylab=&quot;Pressure (hPa)&quot;, xlab=&quot;Date&quot;) # Add the classification to the plot points(PAM_data$pressure$date, PAM_data$pressure$obs, col=pressure_classification$colour, pch=16, cex=0.8) # Add a legend to see which color matches which classification legend( PAM_data$pressure$date[length(PAM_data$pressure$date)/2],800 , c(&quot;Unclassified&quot;, &quot;Active&quot;, &quot;Migrating&quot; ) , col = c(&quot;black&quot;, &quot;royalblue3&quot;,&quot;orange&quot;), pch=16) # PLOT A SUBSET OF THE DATA id = 400:3500 # plot the pressure data plot(PAM_data$pressure$date[id], PAM_data$pressure$obs[id], type=&quot;l&quot;, ylab=&quot;Pressure (hPa)&quot;, xlab=&quot;Date&quot;) # Add the classification to the plot points(PAM_data$pressure$date[id], PAM_data$pressure$obs[id], col=pressure_classification$colour[id], pch=16) # Add a legend to see which color matches which classification legend( PAM_data$pressure$date[id[length(id)-700]],800 , c(&quot;Unclassified&quot;, &quot;Active&quot;, &quot;Migrating&quot; ) , col = c(&quot;black&quot;, &quot;royalblue3&quot;,&quot;orange&quot;), pch=16) 10.6 Classify using pressure Note from the previous classification where the pressure is very low, and therefore at very high altitudes, yet it was not active. This is because bee-eaters soar glide, and using this strategy, they flap their wings very little. Another way of classifying flight events, is to use a change in pressure greater than what we would expect from weather. In this case, pressure data are collected every 30 minutes, and we wouldn’t expect a pressure change greater than 2hPa/30 minutes when the bird is on the ground (you can for instance use nightime when birds do not fly to determine what this threshold should be). Thus we set Pdiff_thld = 2. # twl = GeoLight::twilightCalc(PAM_data$light$date, PAM_data$light$obs, # LightThreshold = 2, # ask = FALSE) TOclassify = pamPREP(dta = PAM_data, method= &quot;pressure&quot;, Pdiff_thld = 2, light_thld = 2, twl = twl, interp = TRUE) # Get rid of any extra NAs TOclassify = TOclassify[complete.cases(TOclassify),] # Select the columns to use as predictors in the model predictor = TOclassify[, c(&quot;duration&quot;, &quot;night_P_diff&quot;, &quot;median_pitch&quot;, &quot;total_daily_P_change&quot;)] # Perform the classification classification = classifyPAM(predictor, states=2, method = &quot;hmm&quot;) ## converged at iteration 19 with logLik: -7954.512 10.6.1 Translate the classification events into something usable # Convert the events to data pressure_classification = classification2PAM(from = TOclassify$start, to = TOclassify$end, classification = classification$cluster, addTO = PAM_data$pressure) pressure_classification = data.frame(cluster=pressure_classification) # Find the pressure difference for each state P_state1 = median(TOclassify$total_daily_P_change[classification$cluster == 1]) P_state2 = median(TOclassify$total_daily_P_change[classification$cluster == 2]) P_states = c(P_state1, P_state2) # Allocate the state with the highest pressure difference to migration Mig_state = which(P_states == max(P_states)) # Now add this information to the classification pressure_classification$states = pressure_classification$cluster pressure_classification$states[pressure_classification$cluster == Mig_state] = &quot;Migration&quot; pressure_classification$states[pressure_classification$cluster != Mig_state] = &quot;Active&quot; pressure_classification$states[is.na(pressure_classification$cluster)] = &quot;Unclassified&quot; # Associate each state with a color pressure_classification$colour = pressure_classification$cluster pressure_classification$colour[pressure_classification$cluster == Mig_state] = &quot;orange&quot; pressure_classification$colour[pressure_classification$cluster != Mig_state] = &quot;royalblue3&quot; pressure_classification$colour[is.na(pressure_classification$cluster)] = &quot;black&quot; # Store for later endurance_classification = pressure_classification 10.6.2 Plot the classification Here we only plot sowthward migration, to help visualise the classification results. par(mar=c(3,3,1,1)) # PLOT ALL THE DATA # plot the pressure data plot(PAM_data$pressure$date, PAM_data$pressure$obs, type=&quot;l&quot;, ylab=&quot;Pressure (hPa)&quot;, xlab=&quot;Date&quot;) # Add the classification to the plot points(PAM_data$pressure$date, PAM_data$pressure$obs, col=pressure_classification$colour, pch=16, cex=0.8) # Add a legend to see which color matches which classification legend( PAM_data$pressure$date[length(PAM_data$pressure$date)/2],800 , c(&quot;Unclassified&quot;, &quot;Active&quot;, &quot;Migrating&quot; ) , col = c(&quot;black&quot;, &quot;royalblue3&quot;,&quot;orange&quot;), pch=16) # PLOT A SUBSET OF THE DATA id = 400:3500 # plot the pressure data plot(PAM_data$pressure$date[id], PAM_data$pressure$obs[id], type=&quot;l&quot;, ylab=&quot;Pressure (hPa)&quot;, xlab=&quot;Date&quot;) # Add the classification to the plot points(PAM_data$pressure$date[id], PAM_data$pressure$obs[id], col=pressure_classification$colour[id], pch=16) # Add a legend to see which color matches which classification legend( PAM_data$pressure$date[id[length(id)-700]],800 , c(&quot;Unclassified&quot;, &quot;Active&quot;, &quot;Migrating&quot; ) , col = c(&quot;black&quot;, &quot;royalblue3&quot;,&quot;orange&quot;), pch=16) 10.7 Classify using a changepoint analysis The changepoint analysis looks for changes in the mean and/or variance in the data, and can be implemented in PAMLr using changePAM. We can perform this and compare with the previous classification seen above. It seems like changePAM overclassifies migration within the migratory period, which classifyPAM overclassifies migration during the non-breeding season in Africa. changepoints = changePAM(PAM_data$pressure$obs) # plot the timeseries plot(PAM_data$pressure$date, PAM_data$pressure$obs, type=&quot;l&quot;, ylab=&quot;Pressure (hPa)&quot;, xlab=&quot;Date&quot;) # Add the classification to the plot points(PAM_data$pressure$date, PAM_data$pressure$obs, col=pressure_classification$colour, pch=16, cex=0.8) # Add a legend to see which color matches which classification legend( PAM_data$pressure$date[length(PAM_data$pressure$date)/2],800 , c(&quot;Unclassified&quot;, &quot;Active&quot;, &quot;Migrating&quot; ) , col = c(&quot;black&quot;, &quot;royalblue3&quot;,&quot;orange&quot;), pch=16) # Add the changepoints abline(v=PAM_data$pressure$date[changepoints$changepoints], col=&quot;red&quot;, lwd=2) 10.8 Compare the classifications results = compareCLASS(date=PAM_data$pressure$date, classifications = data.frame(class1 = endurance_classification$states, class2 = pressure_classification$states)) 10.8.1 Plot the agreement between the migration classifications plot(PAM_data$pressure$date, PAM_data$pressure$obs, type = &quot;l&quot;, xlab=&quot;Date&quot;, ylab=&quot;Pressure (hPa)&quot;, col=&quot;royalblue3&quot;) points(PAM_data$pressure$date, PAM_data$pressure$obs, cex=results$Migration / 2, col=&quot;orange&quot;, pch = 16) "],
["swift.html", "11 Example 3: flap-glide 11.1 Classifying migratory flight Alpine swifts: The dataset 11.2 Visualise data 11.3 What should we look for? 11.4 Classify migration using a hidden markov model 11.5 Find which state is the migratory state 11.6 Plot the classification as a sensor image", " 11 Example 3: flap-glide Figure 11.1: Photograph by Pau Artigas, (c) creative commons 11.1 Classifying migratory flight Alpine swifts: The dataset Alpine swift (Apus melba) have been tracked on the their migrations from Switzerland to sub-Saharan Africa using SOI-GDL3pam loggers. Pressure is recorded every 15 minutes Light is recorded every 2 minutes Activity is recorded every 5 minutes Pitch is recorded every 5 minutes Temperature is recorded every 15 minutes Tri-axial acceleration is recorded every 4 hours Tri-axial magnetic field is recorded every 4 hours data(&quot;swift&quot;) # make sure the cropping period is in the correct date format start = as.POSIXct(&quot;2016-09-01&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) end = as.POSIXct(&quot;2017-04-10&quot;,&quot;%Y-%m-%d&quot;, tz=&quot;UTC&quot;) # Crop the data PAM_data= cutPAM(swift,start,end) 11.2 Visualise data Sensor images are a good place to start when analysing data, as they can give a rapid overview of the dataset. Darker colors represent lower values, and lighter colors (in this case yellow) represent higher values. Sensor images for activity (also known as an actogram), pitch, pressure and temperature are a good place to start. The following code plots this for us: par(mfrow= c(1,4), # number of panels oma=c(0,2,0,6), # outer margin around all panels mar = c(4,1,4,1)) # inner margin around individual fivure sensorIMG(PAM_data$acceleration$date, ploty=FALSE, PAM_data$acceleration$act, main = &quot;Activity&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(PAM_data$acceleration$date, plotx=TRUE, ploty=FALSE, labely=FALSE, PAM_data$acceleration$pit, main=&quot;Pitch&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(PAM_data$pressure$date, plotx=TRUE, ploty=FALSE, labely=FALSE, PAM_data$pressure$obs, main=&quot;Pressure&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(PAM_data$temperature$date, labely=FALSE, PAM_data$temperature$obs, main=&quot;Temperature&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) 11.3 What should we look for? Some pattern start to stick out. Migration appears very short The birds are active all year round Pressure is lower during migration indicating higher altitude flights, particularly during night Temperature is lower during migration also indicating higher altitudes TOclassify = rollPAM(PAM_data, resolution_out = 30 , window = 24*60, interp = FALSE) 11.3.1 Plot the classifiers This helps think about which classifiers show differences for the behaviours we are trying to classify. # choose variables of interest varint = c(&quot;sd_pit&quot;, &quot;sd_pressure&quot;, &quot;median_temperature&quot;, &quot;min_gZ&quot;, &quot;max_act&quot;, &quot;median_pressure&quot;, &quot;median_mY&quot;, &quot;sd_mZ&quot;) #plot these variables of interest par(mfrow=c(4,1), mar=c(4,4,0.5,0.5)) for (i in 1:length(varint)){ plot(TOclassify$date, TOclassify[,varint[i]], type=&quot;l&quot;, xlab=&quot;Date&quot;, ylab = varint[i]) } 11.4 Classify migration using a hidden markov model One of the most difficult aspects of creating a classification is determining how many classes should be used. Here, we increase the number of classes until the behaviour we want to classify is correcly classified. Once this is done, we can extract this classification from the data. # Select the columns to use as predictors in the model predictor = TOclassify[, varint] # Perform the classification classification = classifyPAM(predictor, states = 7, method = &quot;hmm&quot;) ## converged at iteration 35 with logLik: -404282.7 11.5 Find which state is the migratory state To do this, we find the state where pressure was the lowest, i.e. the bird was at the highest altitude, making the assumption that this is when the bird migrates. #what is the minimum pressure for each class? minP = unlist(lapply(1:length(unique(classification$cluster)), function(i) min(TOclassify$median_pressure[classification$cluster==i]))) # which class has the smallest minimum pressure mig_state = which(minP == min(minP)) # create a new classification which is just migration, non-migration mig_classification = ifelse(classification$cluster == mig_state,2,1) 11.6 Plot the classification as a sensor image Another way of looking at a classification is to use a sensor image of the results and to plot it side by side with the raw data to see if the same patterns are being picked out. We can also add (for instance sunset and sunrise events) par(mfrow= c(1,3), # number of panels oma=c(0,2,0,6), # outer margin around all panels mar = c(4,1,4,1)) # inner margin around individual fivure col=c(&quot;royalblue3&quot;, &quot;orange&quot;) sensorIMG(PAM_data$acceleration$date, ploty=FALSE, PAM_data$acceleration$act, main = &quot;Activity&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(PAM_data$pressure$date, plotx=TRUE, ploty=FALSE, labely=FALSE, PAM_data$pressure$obs, main=&quot;Pressure&quot;, col=c(&quot;black&quot;,viridis::cividis(90)), cex=1.2, cex.main = 2) sensorIMG(TOclassify$date, labely=FALSE, mig_classification, main=&quot;Classification&quot;, col=col, cex=1.2, cex.main = 2) # estimate sunrises and sunsets twilights &lt;- GeoLight::twilightCalc(PAM_data$light$date, PAM_data$light$obs, LightThreshold = 2, ask = FALSE) # Add sunrises and sunsets addTWL(twilights$tFirst, offset=0, col= ifelse(twilights$type == 1, &quot;grey&quot;,&quot;black&quot;), pch=16, cex=0.5) "],
["outook.html", "12 A few last things to think about 12.1 Cutting the data 12.2 Clock drift 12.3 Using biologically meaningful patterns 12.4 Data resolution and interpolation 12.5 Using supervised machine learning", " 12 A few last things to think about 12.1 Cutting the data Never forget that loggers can record data even when they are not attached to an animal. Often the logger is taken off, stored in a backpack, driven home or posted to a lab for download. Always make sure the analysis starts and stops when the logger was on the bird. The function cutPAM is specifically setup for getting rid of these unwanted periods. 12.2 Clock drift As the battery runs out throughout the year, the clock on a logger can get gradually become slower and slower. There are a number of methods for correcting for this. The bird/animal will always be caught at a known location. It’s best therefore to find the sunset and sunrise times for the known location, and to see by how many minutes the sunrise and sunset estimated from the light sensor differ from the true sunrise and sunset. It’s then possible to linearly interpolate the timeseries by the known number of minutes. This can be implemented in using the function clockDRIFT. 12.3 Using biologically meaningful patterns The analysis of multisensor geolocator data can be approached from many angles. It’s therefore important to use measures which are translatable into behaviour and to think carefully about the ecology of a species. Here are a few important points to keep in mind: Pressure can change as a result of weather, not just flight. Think about the data resolution and use a weather station to investigate background pressure changes over the same time periods as the data are collected. Feathers and fur can tamper with sensor readings. For instance feathers can cover light sensors or insulate the device from correclty recording temperature - be aware of these. They may even come to your advange, fo instance, a change in darkness could be used to understand moult. Do not use activity as a proxy for foraging success. A bird could for instance be very active because it has to search a lot for food (low success rate). However, resting can definitely be used to quantify a lack of foraging. Activity can result from many things - hopping or flapping. Think about it carefully when using it. For instance, high activity and high pressure change are likely to mean flying, but high acitivity and no pressure change are less clear. Pressure is only recorded every half hour, and activity every 5 minutes - so the bird could have flown in between the two pressure recordings but we would have no way of telling. Recommendation: be aware of the limitations of the data 12.4 Data resolution and interpolation The temporal resolution of the data vary between sensors. It’s important to think about what resolution the analysis should be carried out at. For instance, with tri-axial measurements taken every 4 hours, it’s impossible to perform dead reckoning, or to look at an individual flight event. If there are missing data, be aware that some methods will not work for classifying behaviour If data are infrequent, refrain from using them for classification. If they are absolutely necessary, it’s possible to interpolate linearly between two values. However, a better alternative would be to use a rolling window to derive statistics . See data preparation for more information. 12.5 Using supervised machine learning Here, the examples are geared towards migratory birds with tags recording less frequently over long periods. However, with an increase in data resolution over a shorter period, and on-ground observations, it’s also possible to develop supervised learning techniques, look at dead reckoning, turning point classification, and much more, not just for birds. There are many possibilities. "]
]
